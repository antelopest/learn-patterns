# DRY (Don't Repeat Yourself, "Не повторяйся")

Принцип DRY — это подход к разработке, который направлен на уменьшение дублирование кода.
Основная идея: каждая часть логики должна быть определена только один раз, чтобы упростить поддержку, тестирование и
изменение кода.

## Что такое DRY?

DRY подразумевает, что повторяющийся код или логика должны быть вынесены в отдельные функции, классы, модули или
константы.

Это снижает вероятность ошибок, упрощает рефакторинг и улучшает читаемость. Нарушение DRY часто приводит к антипаттерну
WET (Write Every Twice, "Пиши все дважды").

## Примеры нарушения DRY и их исправление

### Пример Повторяющийся код в обработке данных

**Проблема:** Нарушение DRY

Предположим, у нас есть несколько функций, которые форматируют данные пользователя в разных частях приложения, но делают
это одинаково.

```ts
function getUserFullName(user: { firstName: string; lastName: string }) {
    return `${user.firstName} ${user.lastName}`;
}

function displayUser(user: { firstName: string; lastName: string }) {
    console.log(`${user.firstName} ${user.lastName}`);
}

function saveUser(user: { firstName: string; lastName: string }) {
    const fullName = `${user.firstName} ${user.lastName}`;

    console.log(`Saving: ${fullName}`);
}

const user = {firstName: 'John', lastName: 'Doe'};

console.log(getUserFullName(user));
displayUser(user);
saveUser(user);
```

#### Проблема:

Логика формирования полного имени `${user.firstName} ${user.lastName}` повторяется в трех местах.
Если потребуется изменить формат (например, добавить отчество), придется менять код в нескольких местах, что увеличивает
риск ошибок.

#### Решение (DRY)

Выносим логику формирования полного имени в отдельную функцию или метод.

```ts
function getFullName(user: { firstName: string; lastName: string }) {
    return `${user.firstName} ${user.lastName}`;
}

function getUserFullName(user: { firstName: string; lastName: string }) {
    return getFullName(user);
}

function displayUser(user: { firstName: string; lastName: string }) {
    console.log(getFullName(user));
}

function saveUser(user: { firstName: string; lastName: string }) {
    const fullName = getFullName(user);

    console.log(`Saving: ${fullName}`);
}

function getFullName(user: { firstName: string; lastName: string }): string {
    return `${user.firstName} ${user.lastName}`;
}

function getUserFullName(user: { firstName: string; lastName: string }) {
    return getFullName(user);
}

function displayUser(user: { firstName: string; lastName: string }) {
    console.log(`User: ${getFullName(user)}`);
}

function saveUser(user: { firstName: string; lastName: string }) {
    const fullName = getFullName(user);
    console.log(`Saving: ${fullName}`);
}

const user = {firstName: "John", lastName: "Doe"};
console.log(getUserFullName(user)); // John Doe
displayUser(user); // User: John Doe
saveUser(user); // Saving: John Doe
```

### Почему лучше:

* Логика формирования имени определена в одном месте (`getFullName`).
* Если нужно изменить формат (например, добавить middleName), достаточно обновить только функцию `getFullName`.

### Пример Дублирование типов

**Проблема:** Нарушение DRY

В TypeScript часто дублируют типы или интерфейсы для похожих сущностей.

```ts
interface User {
    id: number;
    firstName: string;
    lastName: string;
}


interface Admin {
    id: number;

    firstName: string;
    lastName: string;
    role: string;
}

function printUser(user: User) {
    console.log(`User: ${user.firstName} ${user.lastName}`);
}

function printAdmin(admin: Admin) {
    console.log(`Admin: ${admin.firstName} ${admin.lastName}, Role: (${admin.role})`);
}
```

**Проблема:** Интерфейсы `User` и `Admin` содержат одинаковые поля `id`, `firstName`, `lastName`. Если нужно добавить
новое поле (например, `email`), придется менять оба интерфейса.

```ts
interface Profile {
    id: number;
    firstName: string;
    lastName: string;
    email: string;
}

interface Admin extends Profile {
    role: string;
}

function printUser(user: Person) {
    console.log(`User: ${user.firstName} ${user.lastName}`);
}

function printAdmin(admin: Admin) {
    console.log(`Admin: ${admin.firstName} ${admin.lastName}, Role: ${admin.role}`);
}

const user: Person = {id: 1, firstName: "John", lastName: "Doe"};
const admin: Admin = {id: 2, firstName: "Jane", lastName: "Smith", role: "admin"};
printUser(user); // User: John Doe
printAdmin(admin); // Admin: Jane Smith, Role: admin
```

### Почему лучше:

* Общие поля вынесены в базовый интерфейс `Person`.
* Изменение структуры (например, добавление `email`) затрагивает только `Person`.

### Пример Повторяющаяся валидация

**Проблема:** Нарушение DRY

Предположим, мы валидируем email в нескольких местах приложения.

```ts
function registerUser(email: string, password: string) {
    if (!email.includes('@') || !email.includes('.')) {
        throw new Error('Invalid email');
    }

    console.log('User registered: ', email);
}

function updateUserEmail(userId: number, email: string) {
    if (!email.includes("@") || !email.includes(".")) {
        throw new Error("Невалидный email");
    }
    console.log(`User updated: ${userId}: ${email}`);
}

registerUser("test@example.com", "password123");
updateUserEmail(1, "new@example.com");
```

**Проблема:** Логика валидации email повторяется в обеих функциях. Если нужно изменить правила валидации (например,
добавить проверку длины), придется обновлять код в нескольких местах.

**Решение (DRY):**

Выносим валидацию в отдельную функцию.

```ts
function validateEmail(email: string): void {
    if (!email.includes("@") || !email.includes(".")) {
        throw new Error(`Invalid email: ${email}`);
    }
}

function registerUser(email: string, password: string) {
    validateEmail(email);
    console.log(`Register user: ${email}`);
}

function updateUserEmail(userId: number, email: string) {
    validateEmail(email);
    console.log(`Update email for user ${userId}: ${email}`);
}

registerUser("test@example.com", "password123");
updateUserEmail(1, "new@example.com");
```

**Почему лучше:**

* Валидация определена в одном месте (`validateEmail`).
* Легко изменить правила валидации, обновив только одну функцию.

## Практические советы по применению DRY в TypeScript

### Используйте функции и утилиты:

* Создавайте переиспользуемые утилиты для часто повторяющихся операций (форматирование, валидация, преобразование
  данных).

### Леверидж типов и интерфейсов

* Используйте наследование интерфейсов или утилитные типы (Patrial, Pick, Omit) для избежания дублирования.

```ts
type BaseEntity = {
    id: number;
    createdAt: Date;
};

type User = BaseEntity & {
    name: string;
};

type Product = BaseEntity & {
    price: number;
};
```

### Константы и конфиги

* Выносите повторяющиеся значения (например, строки, числа, URL) в константы или конфигурационные файлы.

```ts
const API_URLS = {
    USERS: "/api/users",
    PRODUCTS: "/api/products"
} as const;
```

### Избегайте чрезмерного DRY

* Иногда излишняя абстракция усложняет код. Например, не стоит объединять функции с разной семантикой только из-за
  похожей структуры.

## Когда DRY может навредить?

* **Преждевременная оптимизация:** Создание сложных абстракций для кода, который используется только один раз,
  увеличивает сложность без выгоды.
* **Семантическая разница:** Если две функции выглядят одинаково, но имеют разный контекст (например, валидация email
  для регистрации и для обновления профиля), их объединение может запутать.

Пример:

```ts
function validateRegistrationEmail(email: string) {
    // Специфические правила для регистрации
}

function validateUpdateEmail(email: string) {
    // Другие правила для обновления
}
```

Здесь лучше сохранять отдельные функции, если требования к валидации различаются.

## Заключение

Принцип DRY помогает уменьшить дублирование, улучшить читаемость и упростить поддержку кода.
Ключевые инструменты:

* Функции и утилиты для повторяющийся логики.
* Интерфейсы и типы для устранения дублирования структур данных.
