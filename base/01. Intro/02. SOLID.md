# SOLID-принципы

SOLID — это акроним для пяти принципов проектирования, которые помогают писать масштабируемый и поддерживаемый код.

## S - Single Responsibility Principle (Принцип единственной ответственности)

**Идея:** Класс или модуль должен иметь только одну причину для изменения.

**Пример:**

```ts
class UserService {
    fetchUser(userId: number) {
    }

    saveUser(user: any) {
    }

    sendEmail(user: any, message: string) {
    }
}
```

Этот класс делает слишком много: работает с данными и отправляет письма.

**Пример:** с использованием Принципа единственной ответственности

```ts
class UserRepository {
    fetchUser(userId: number) {
    }

    saveUser(user: any) {
    }
}

class EmailService {
    sendEmail(user: any, message: string) {
    }
}
```

**Почему лучше:** Разделение ответственности упрощает тестирование и поддержку.

## O - Open/Closed Principle (Принцип открытости/закрытости)

**Идея:** Классы должны быть открыты для расширения, но закрыты для модификации.

**Пример:**

```ts
class Discount {
    calculate(price: number, type: string) {
        if (type === "student") return price * 0.9;
        if (type === "senior") return price * 0.8;

        return price;
    }
}
```

Добавление нового типа скидки требует изменения класса.

**Пример:** с использованием Принципа открытости/закрытости

```ts
interface DiscountStrategy {
    calculate(price: number): number;
}

class StudentDiscount implements DiscountStrategy {
    calculate(price: number) {
        return price * 0.9;
    }
}

class SeniorDiscount implements DiscountStrategy {
    calculate(price: number) {
        return price * 0.8;
    }
}

class Discount {
    constructor(private strategy: DiscountStrategy) {
    }

    calculate(price: number) {
        return this.strategy.calculate(price);
    }
}
```

**Почему лучше:** Новые скидки добавляются через новые классы, не меняя существующий код.

## L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

**Идея:** Объекты базового класса можно заменить объектами производного класса без изменения поведения программы.

**Пример:**

**Пример:**

## I - Interface Segregation Principle (Принцип разделения интерфейсов)

**Идея:** Клиенты не должны зависеть от интерфейсов, которые они не используют.

**Пример:**

```ts
interface Worker {
    work(): void;

    eat(): void;
}

class Robot implements Worker {
    work() {
        console.log("Working!");
    }

    eat() {
        throw new Error("Robot's can't eat!");
    }
}
```

**Пример:** с использованием Принципы разделения интерфейсов

```ts
interface Workable {
    work(): void;
}

interface Eatable {
    eat(): void;
}

class Robot implements Workable {
    work() {
        console.log("Working!");
    }
}

class Human implements Workable, Eatable {
    work() {
        console.log("Working!");
    }

    eat() {
        console.log("Eating!");
    }
}
```

**Почему лучше:** Разделение интерфейсов делает код более гибким.

## D - Dependency Inversion Principle (Принцип инверсии зависимостей)

**Идея:** Модули высокого уровня не должны зависеть от модулей низкого уровня; оба должны зависеть от абстракций.

**Пример:**

```ts
class Database {
    save(data: any) {
    }
}

class UserService {
    private db = new Database();

    saveUser(user: any) {
        this.db.save(user);
    }
}
```

UserService сильно зависит от Database.

**Пример:** с использованием Принципа инверсии зависимостей

```ts
interface Storage {
    save(data: any): void;
}

class Database implements Storage {
    save(data: any) { /* ... */
    }
}

class UserService {
    constructor(private storage: Storage) {
    }

    saveUser(user: any) {
        this.storage.save(user);
    }
}

const db = new Database();
const userService = new UserService(db);
```

**Почему лучше:** Инверсия зависимостей позволяет легко заменить Database, например, на FileStorage.